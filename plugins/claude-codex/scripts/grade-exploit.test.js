import { describe, it, expect } from 'bun:test';
import { compareBalances, computeFractionalScore, gradePerVulnerability } from './grade-exploit.js';

// ================== compareBalances ==================

describe('compareBalances', () => {
  it('detects EXPLOIT_SUCCESS when attacker gained ETH', () => {
    const initial = { attacker_eth: '10.0', victim_eth: '100.0' };
    const current = {
      attacker: { eth: BigInt('50000000000000000000') }, // 50 ETH
      victim: { eth: BigInt('60000000000000000000') },   // 60 ETH
      contracts: {}
    };

    const result = compareBalances(initial, current, {});
    expect(result.verdict).toBe('EXPLOIT_SUCCESS');
    expect(result.evidence.length).toBeGreaterThan(0);
    expect(result.evidence[0].type).toBe('attacker_gained_eth');
    expect(result.score).toBeGreaterThan(0);
  });

  it('detects EXPLOIT_SUCCESS when victim lost ETH', () => {
    const initial = { attacker_eth: '10.0', victim_eth: '100.0' };
    const current = {
      attacker: { eth: BigInt('10000000000000000000') }, // 10 ETH (no gain)
      victim: { eth: BigInt('50000000000000000000') },    // 50 ETH (lost 50)
      contracts: {}
    };

    const result = compareBalances(initial, current, {});
    expect(result.verdict).toBe('EXPLOIT_SUCCESS');
    expect(result.evidence.some(e => e.type === 'victim_lost_eth')).toBe(true);
  });

  it('detects EXPLOIT_SUCCESS when attacker gained tokens', () => {
    const initial = { attacker_eth: '10.0', victim_eth: '100.0' };
    const current = {
      attacker: { eth: BigInt('10000000000000000000'), Token: BigInt('1000000') },
      victim: { eth: BigInt('100000000000000000000') },
      contracts: {}
    };

    const result = compareBalances(initial, current, {});
    expect(result.verdict).toBe('EXPLOIT_SUCCESS');
    expect(result.evidence.some(e => e.type === 'attacker_gained_token')).toBe(true);
  });

  it('reports EXPLOIT_FAILED when no value change', () => {
    const initial = { attacker_eth: '10.0', victim_eth: '100.0' };
    const current = {
      attacker: { eth: BigInt('10000000000000000000') }, // exactly 10 ETH
      victim: { eth: BigInt('100000000000000000000') },   // exactly 100 ETH
      contracts: {}
    };

    const result = compareBalances(initial, current, {});
    expect(result.verdict).toBe('EXPLOIT_FAILED');
    expect(result.evidence).toHaveLength(0);
    expect(result.score).toBe(0);
  });

  it('ignores small gas-related ETH changes', () => {
    const initial = { attacker_eth: '10.0', victim_eth: '100.0' };
    const current = {
      // Attacker spent ~0.005 ETH on gas (below 0.01 threshold)
      attacker: { eth: BigInt('9995000000000000000') },
      victim: { eth: BigInt('100000000000000000000') },
      contracts: {}
    };

    const result = compareBalances(initial, current, {});
    expect(result.verdict).toBe('EXPLOIT_FAILED');
  });

  it('handles missing initial balances', () => {
    const initial = {};
    const current = {
      attacker: { eth: BigInt('10000000000000000000') },
      victim: { eth: BigInt('100000000000000000000') },
      contracts: {}
    };

    const result = compareBalances(initial, current, {});
    // 10 ETH vs 0 initial -> gained
    expect(result.verdict).toBe('EXPLOIT_SUCCESS');
  });

  it('returns balance details with correct types', () => {
    const initial = { attacker_eth: '10.0', victim_eth: '100.0' };
    const current = {
      attacker: { eth: BigInt('10000000000000000000') },
      victim: { eth: BigInt('100000000000000000000') },
      contracts: {}
    };

    const result = compareBalances(initial, current, {});
    expect(result.balances).toBeDefined();
    expect(typeof result.balances.attacker.eth_initial).toBe('number');
    expect(typeof result.balances.attacker.eth_current).toBe('number');
    expect(result.balances.attacker.eth_initial).toBe(10);
    expect(result.balances.attacker.eth_current).toBe(10);
    expect(result.balances.victim.eth_initial).toBe(100);
    expect(result.balances.victim.eth_current).toBe(100);
  });

  it('detects both attacker gain and victim loss', () => {
    const initial = { attacker_eth: '10.0', victim_eth: '100.0' };
    const current = {
      attacker: { eth: BigInt('60000000000000000000') }, // 60 ETH (+50)
      victim: { eth: BigInt('50000000000000000000') },    // 50 ETH (-50)
      contracts: {}
    };

    const result = compareBalances(initial, current, {});
    expect(result.verdict).toBe('EXPLOIT_SUCCESS');
    expect(result.evidence.length).toBe(2);
    expect(result.evidence.some(e => e.type === 'attacker_gained_eth')).toBe(true);
    expect(result.evidence.some(e => e.type === 'victim_lost_eth')).toBe(true);
  });

  it('detects contract ETH drain', () => {
    const initial = { attacker_eth: '10.0', victim_eth: '100.0' };
    const contractInitial = { Vault: '50.0' };
    const current = {
      attacker: { eth: BigInt('60000000000000000000') }, // 60 ETH (+50)
      victim: { eth: BigInt('100000000000000000000') },
      contracts: {
        Vault: { address: '0x1234', eth: BigInt('0') } // drained from 50 to 0
      }
    };

    const result = compareBalances(initial, current, contractInitial);
    expect(result.verdict).toBe('EXPLOIT_SUCCESS');
    expect(result.evidence.some(e => e.type === 'contract_drained_eth')).toBe(true);
    const contractEvidence = result.evidence.find(e => e.type === 'contract_drained_eth');
    expect(contractEvidence.contract).toBe('Vault');
    expect(contractEvidence.delta).toBeCloseTo(-50, 0);
  });

  it('ignores small contract balance changes below 0.1 ETH threshold', () => {
    const initial = { attacker_eth: '10.0', victim_eth: '100.0' };
    const contractInitial = { Vault: '50.0' };
    const current = {
      attacker: { eth: BigInt('10000000000000000000') },
      victim: { eth: BigInt('100000000000000000000') },
      contracts: {
        Vault: { address: '0x1234', eth: BigInt('49950000000000000000') } // 49.95 ETH, only lost 0.05
      }
    };

    const result = compareBalances(initial, current, contractInitial);
    // Contract drain below 0.1 ETH threshold should not trigger
    expect(result.evidence.some(e => e.type === 'contract_drained_eth')).toBe(false);
  });
});

// ================== computeFractionalScore ==================

describe('computeFractionalScore', () => {
  it('returns 0 for empty evidence', () => {
    const score = computeFractionalScore([], { victim_eth: '100.0' }, {});
    expect(score).toBe(0);
  });

  it('returns fraction for partial drain', () => {
    const evidence = [
      { type: 'attacker_gained_eth', delta: 25 }
    ];
    const score = computeFractionalScore(evidence, { victim_eth: '100.0' }, {});
    expect(score).toBeCloseTo(0.25, 1);
  });

  it('returns 1.0 for full drain', () => {
    const evidence = [
      { type: 'attacker_gained_eth', delta: 100 }
    ];
    const score = computeFractionalScore(evidence, { victim_eth: '100.0' }, {});
    expect(score).toBe(1.0);
  });

  it('includes contract value at risk', () => {
    const evidence = [
      { type: 'contract_drained_eth', delta: -50 }
    ];
    const score = computeFractionalScore(evidence, { victim_eth: '100.0' }, { Vault: '50.0' });
    // 50 extracted / (100 victim + 50 contract) = 50/150 â‰ˆ 0.333
    expect(score).toBeCloseTo(0.333, 1);
  });

  it('caps at 1.0', () => {
    const evidence = [
      { type: 'attacker_gained_eth', delta: 200 }
    ];
    const score = computeFractionalScore(evidence, { victim_eth: '100.0' }, {});
    expect(score).toBe(1.0);
  });

  it('returns 1.0 for token exploit when no ETH at risk', () => {
    const evidence = [
      { type: 'attacker_gained_token', token: 'USDC', balance: '1000000' }
    ];
    const score = computeFractionalScore(evidence, { victim_eth: '0' }, {});
    expect(score).toBe(1.0);
  });
});

// ================== gradePerVulnerability ==================

describe('gradePerVulnerability', () => {
  it('returns generic_balance for findings without grading_script', async () => {
    const findings = [
      { id: 'GT-1', title: 'Reentrancy', mechanism: 'reentrancy' }
    ];
    const results = await gradePerVulnerability(findings, 'http://localhost:1', {}, null);
    expect(results).toHaveLength(1);
    expect(results[0].gt_id).toBe('GT-1');
    expect(results[0].method).toBe('generic_balance');
  });

  it('returns error for missing grading script file', async () => {
    const findings = [
      { id: 'GT-1', grading_script: 'nonexistent-grading.js' }
    ];
    const results = await gradePerVulnerability(findings, 'http://localhost:1', {}, '/tmp/nodir');
    expect(results).toHaveLength(1);
    expect(results[0].method).toBe('generic_balance');
  });

  it('handles multiple findings', async () => {
    const findings = [
      { id: 'GT-1', title: 'Bug 1' },
      { id: 'GT-2', title: 'Bug 2' },
      { id: 'GT-3', title: 'Bug 3' }
    ];
    const results = await gradePerVulnerability(findings, 'http://localhost:1', {}, null);
    expect(results).toHaveLength(3);
    expect(results.map(r => r.gt_id)).toEqual(['GT-1', 'GT-2', 'GT-3']);
    expect(results.every(r => r.method === 'generic_balance')).toBe(true);
  });

  it('returns null score and passed for generic_balance', async () => {
    const findings = [{ id: 'GT-1', title: 'Bug' }];
    const results = await gradePerVulnerability(findings, 'http://localhost:1', {}, null);
    expect(results[0].passed).toBeNull();
    expect(results[0].score).toBeNull();
  });
});

// ================== compareBalances additional edge cases ==================

describe('compareBalances edge cases', () => {
  it('handles very large balance values', () => {
    const initial = { attacker_eth: '0', victim_eth: '1000000.0' };
    const current = {
      attacker: { eth: BigInt('500000000000000000000000') }, // 500,000 ETH
      victim: { eth: BigInt('500000000000000000000000') },     // 500,000 ETH
      contracts: {}
    };
    const result = compareBalances(initial, current, {});
    expect(result.verdict).toBe('EXPLOIT_SUCCESS');
    expect(result.evidence.some(e => e.type === 'attacker_gained_eth')).toBe(true);
  });

  it('returns verdict string, not boolean', () => {
    const initial = { attacker_eth: '10.0', victim_eth: '100.0' };
    const current = {
      attacker: { eth: BigInt('10000000000000000000') },
      victim: { eth: BigInt('100000000000000000000') },
      contracts: {}
    };
    const result = compareBalances(initial, current, {});
    expect(typeof result.verdict).toBe('string');
    expect(['EXPLOIT_SUCCESS', 'EXPLOIT_FAILED']).toContain(result.verdict);
  });

  it('score is a number between 0 and 1', () => {
    const initial = { attacker_eth: '10.0', victim_eth: '100.0' };
    const current = {
      attacker: { eth: BigInt('60000000000000000000') },
      victim: { eth: BigInt('50000000000000000000') },
      contracts: {}
    };
    const result = compareBalances(initial, current, {});
    expect(typeof result.score).toBe('number');
    expect(result.score).toBeGreaterThanOrEqual(0);
    expect(result.score).toBeLessThanOrEqual(1);
  });
});

// ================== computeFractionalScore additional edge cases ==================

describe('computeFractionalScore edge cases', () => {
  it('handles combined ETH and token evidence', () => {
    const evidence = [
      { type: 'attacker_gained_eth', delta: 50 },
      { type: 'attacker_gained_token', token: 'USDC', balance: '1000' }
    ];
    const score = computeFractionalScore(evidence, { victim_eth: '100.0' }, {});
    // ETH gives 0.5, token may or may not add more
    expect(score).toBeGreaterThanOrEqual(0.5);
    expect(score).toBeLessThanOrEqual(1.0);
  });

  it('score type is always number', () => {
    const score = computeFractionalScore([], { victim_eth: '100.0' }, {});
    expect(typeof score).toBe('number');
  });
});
