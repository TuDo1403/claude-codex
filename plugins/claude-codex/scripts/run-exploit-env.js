#!/usr/bin/env bun
/**
 * Run Exploit Environment — Anvil setup + RPC gatekeeper (G4)
 *
 * Starts a local Anvil instance with custom mnemonic (not defaults),
 * deploys contracts, seeds wallets, starts RPC gatekeeper proxy,
 * and outputs deploy-artifacts.json.
 *
 * EVMbench Appendix E: custom mnemonic prevents reliance on known default keys.
 *
 * Usage:
 *   bun run-exploit-env.js --project-dir /path/to/project --run-id <run_id> [options]
 *
 * Environment:
 *   CLAUDE_PROJECT_DIR - Project directory
 */

import { readFileSync, writeFileSync, existsSync, mkdirSync, unlinkSync, readdirSync } from 'fs';
import { join, dirname } from 'path';
import { parseArgs } from 'util';
import { spawn, execSync } from 'child_process';
import { createGatekeeperServer } from './rpc-gatekeeper.js';

const PROJECT_DIR = process.env.CLAUDE_PROJECT_DIR || process.cwd();
const TASK_DIR = join(PROJECT_DIR, '.task');

function parseArguments() {
  const { values } = parseArgs({
    options: {
      'run-id': { type: 'string' },
      'project-dir': { type: 'string' },
      'anvil-port': { type: 'string' },
      'gatekeeper-port': { type: 'string' },
      'seed-eth': { type: 'string' },
      'no-gatekeeper': { type: 'boolean' },
      'timeout': { type: 'string' },
      help: { type: 'boolean', short: 'h' }
    },
    allowPositionals: true
  });

  if (values.help) {
    console.log(`
Usage: run-exploit-env.js [options]

Start Anvil + RPC gatekeeper for live chain exploit verification.

Options:
  --run-id           Run ID for this pipeline execution
  --project-dir      Project directory (default: CLAUDE_PROJECT_DIR)
  --anvil-port       Anvil listen port (default: 8545)
  --gatekeeper-port  Gatekeeper proxy port (default: 8546)
  --seed-eth         ETH to seed victim wallet (default: 100)
  --no-gatekeeper    Skip gatekeeper proxy (not recommended)
  --timeout          Auto-shutdown timeout in ms (default: 300000)
  -h, --help         Show this help message
    `);
    process.exit(0);
  }

  return values;
}

function ensureDir(dir) {
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }
}

/**
 * Generate a valid BIP-39 mnemonic (12 words) using Foundry's cast.
 *
 * Previous implementation assembled random words without BIP-39 checksum,
 * making ~84% of generated phrases invalid for Anvil/cast.
 *
 * BIP-39 requires: 128-bit entropy → SHA-256 → 4 checksum bits → 132 bits
 * → 12 × 11-bit indices into the standard 2048-word list.
 *
 * We delegate to `cast wallet new-mnemonic` which implements this correctly.
 * cast is already a hard dependency (used for private key derivation).
 */
function generateMnemonic() {
  try {
    const output = execSync('cast wallet new-mnemonic --words 12', {
      encoding: 'utf-8',
      timeout: 10000
    }).trim();

    // cast outputs multi-line: "Successfully generated..." then "Phrase:" then the mnemonic.
    // Find the line containing exactly 12 lowercase words.
    const lines = output.split('\n').map(l => l.trim()).filter(Boolean);
    for (const line of lines) {
      const words = line.split(/\s+/);
      if (words.length === 12 && words.every(w => /^[a-z]+$/.test(w))) {
        return line;
      }
    }

    throw new Error(`Could not parse mnemonic from cast output: ${output.slice(0, 200)}`);
  } catch (err) {
    // If cast fails, throw — cast is required for the rest of the pipeline too
    throw new Error(
      `Failed to generate BIP-39 mnemonic: ${err.message}. ` +
      'Ensure Foundry (cast) is installed: https://book.getfoundry.sh/getting-started/installation'
    );
  }
}

/**
 * Start Anvil with custom mnemonic.
 * Returns { process, mnemonic, port }.
 */
function startAnvil(port, mnemonic) {
  console.log(`Starting Anvil on port ${port}...`);

  const anvilProcess = spawn('anvil', [
    '--mnemonic', mnemonic,
    '--port', String(port),
    '--silent',
    '--accounts', '10',
    '--balance', '1000'
  ], {
    stdio: ['pipe', 'pipe', 'pipe']
  });

  let stderr = '';
  anvilProcess.stderr.on('data', (data) => {
    stderr += data.toString();
  });

  return new Promise((resolve, reject) => {
    // Wait for Anvil to be ready
    const checkInterval = setInterval(async () => {
      try {
        const res = await fetch(`http://localhost:${port}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ jsonrpc: '2.0', method: 'eth_chainId', params: [], id: 1 })
        });
        if (res.ok) {
          clearInterval(checkInterval);
          clearTimeout(failTimeout);
          console.log(`  Anvil ready on port ${port}`);
          resolve({ process: anvilProcess, mnemonic, port });
        }
      } catch {
        // Not ready yet
      }
    }, 200);

    const failTimeout = setTimeout(() => {
      clearInterval(checkInterval);
      anvilProcess.kill();
      reject(new Error(`Anvil failed to start: ${stderr.slice(0, 200)}`));
    }, 15000);

    anvilProcess.on('error', (err) => {
      clearInterval(checkInterval);
      clearTimeout(failTimeout);
      reject(new Error(`Anvil spawn error: ${err.message}`));
    });

    anvilProcess.on('close', (code) => {
      clearInterval(checkInterval);
      clearTimeout(failTimeout);
      if (code !== null && code !== 0) {
        reject(new Error(`Anvil exited with code ${code}: ${stderr.slice(0, 200)}`));
      }
    });
  });
}

/**
 * Derive wallet addresses from mnemonic using Anvil's built-in accounts.
 * Queries Anvil for the account list.
 */
async function deriveWallets(rpcUrl) {
  const res = await fetch(rpcUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ jsonrpc: '2.0', method: 'eth_accounts', params: [], id: 1 })
  });
  const data = await res.json();
  const accounts = data.result || [];

  // Convention: 0=deployer, 1=victim, 9=attacker
  return {
    deployer: { address: accounts[0], index: 0 },
    victim: { address: accounts[1], index: 1 },
    attacker: { address: accounts[9], index: 9 },
    all: accounts
  };
}

/**
 * Get private key for an account index.
 * Anvil derives keys from mnemonic deterministically — use cast to get them.
 */
function getPrivateKey(mnemonic, index) {
  try {
    const output = execSync(
      `cast wallet derive-private-key "${mnemonic}" ${index}`,
      { encoding: 'utf-8', timeout: 10000 }
    ).trim();
    // cast outputs the private key on the last line
    const lines = output.split('\n');
    return lines[lines.length - 1].trim();
  } catch {
    // Fallback: use a well-known derivation
    return null;
  }
}

/**
 * Deploy contracts using forge script or forge create.
 * Returns deployed contract addresses.
 *
 * Per EVMbench Appendix E: deploy scripts are removed after execution
 * to prevent the agent from reading deployment logic that could reveal
 * vulnerability details.
 */
async function deployContracts(projectDir, rpcUrl, deployerPrivateKey) {
  console.log('  Deploying contracts...');
  const contracts = {};

  // Look for deploy script
  const deployScript = join(projectDir, 'script', 'Deploy.s.sol');
  if (existsSync(deployScript)) {
    try {
      const output = execSync(
        `forge script "${deployScript}" --rpc-url "${rpcUrl}" --private-key "${deployerPrivateKey}" --broadcast`,
        { cwd: projectDir, encoding: 'utf-8', timeout: 120000 }
      );
      console.log('  Deploy script executed');

      // Parse deployed addresses from broadcast JSON
      const broadcastDir = join(projectDir, 'broadcast');
      if (existsSync(broadcastDir)) {
        try {
          // Find the latest run JSON in broadcast/
          const scriptName = 'Deploy.s.sol';
          const scriptBroadcastDir = join(broadcastDir, scriptName);
          if (existsSync(scriptBroadcastDir)) {
            const chainDirs = readdirSync(scriptBroadcastDir).filter(d => /^\d+$/.test(d));
            for (const chainDir of chainDirs) {
              const runLatest = join(scriptBroadcastDir, chainDir, 'run-latest.json');
              if (existsSync(runLatest)) {
                const broadcastData = JSON.parse(readFileSync(runLatest, 'utf-8'));
                const txs = broadcastData.transactions || [];
                for (const tx of txs) {
                  if (tx.transactionType === 'CREATE' && tx.contractName && tx.contractAddress) {
                    contracts[tx.contractName] = tx.contractAddress;
                  }
                }
              }
            }
          }
        } catch (parseErr) {
          console.warn(`  Broadcast parse warning: ${parseErr.message.slice(0, 100)}`);
        }
      }
    } catch (err) {
      console.warn(`  Deploy script failed: ${err.message.slice(0, 100)}`);
    }

    // EVMbench Appendix E: Remove deploy script after execution to prevent
    // the agent from reading it and learning about vulnerability details.
    try {
      unlinkSync(deployScript);
      console.log('  Deploy script removed (EVMbench Appendix E hardening)');
    } catch {
      // Non-critical if removal fails
    }
  }

  return contracts;
}

/**
 * Seed wallets with ETH (transfer from deployer to victim/attacker).
 */
async function seedWallets(rpcUrl, deployerAddress, wallets, seedEth) {
  console.log(`  Seeding wallets with ${seedEth} ETH...`);

  // Anvil accounts start with 1000 ETH each, so victim and attacker
  // already have funds. We just verify.
  for (const [role, wallet] of Object.entries(wallets)) {
    if (role === 'all') continue;
    const res = await fetch(rpcUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        jsonrpc: '2.0',
        method: 'eth_getBalance',
        params: [wallet.address, 'latest'],
        id: 1
      })
    });
    const data = await res.json();
    const balanceWei = BigInt(data.result || '0');
    const balanceEth = Number(balanceWei) / 1e18;
    console.log(`    ${role} (${wallet.address}): ${balanceEth.toFixed(2)} ETH`);
  }
}

async function main() {
  const args = parseArguments();
  const runId = args['run-id'] || `exploit-env-${Date.now()}`;
  const projectDir = args['project-dir'] || PROJECT_DIR;
  const anvilPort = parseInt(args['anvil-port'] || '8545');
  const gatekeeperPort = parseInt(args['gatekeeper-port'] || '8546');
  const seedEth = args['seed-eth'] || '100';
  const useGatekeeper = !args['no-gatekeeper'];
  const timeout = parseInt(args.timeout || '300000');

  console.log(`\n=== Live Chain Exploit Environment ===`);
  console.log(`Run ID: ${runId}`);
  console.log(`Project: ${projectDir}`);
  console.log(`Anvil: http://localhost:${anvilPort}`);
  if (useGatekeeper) {
    console.log(`Gatekeeper: http://localhost:${gatekeeperPort}`);
  }

  const runDir = join(TASK_DIR, runId);
  ensureDir(runDir);

  let anvilInstance = null;
  let gatekeeper = null;

  const cleanup = () => {
    console.log('\nCleaning up...');
    if (gatekeeper) {
      try { gatekeeper.close(); } catch {}
      console.log('  Gatekeeper stopped');
    }
    if (anvilInstance?.process) {
      try { anvilInstance.process.kill('SIGTERM'); } catch {}
      console.log('  Anvil stopped');
    }
  };

  process.on('SIGINT', () => { cleanup(); process.exit(0); });
  process.on('SIGTERM', () => { cleanup(); process.exit(0); });

  try {
    // 1. Generate mnemonic
    const mnemonic = generateMnemonic();
    console.log(`\nMnemonic generated (not Anvil defaults per EVMbench Appendix E)`);

    // 2. Start Anvil
    anvilInstance = await startAnvil(anvilPort, mnemonic);

    // 3. Derive wallets
    const rpcUrl = `http://localhost:${anvilPort}`;
    const wallets = await deriveWallets(rpcUrl);
    console.log(`\nWallets derived:`);
    console.log(`  Deployer: ${wallets.deployer.address}`);
    console.log(`  Victim:   ${wallets.victim.address}`);
    console.log(`  Attacker: ${wallets.attacker.address}`);

    // 4. Get private keys
    const attackerKey = getPrivateKey(mnemonic, 9);
    const deployerKey = getPrivateKey(mnemonic, 0);

    // 5. Deploy contracts
    const contracts = await deployContracts(projectDir, rpcUrl, deployerKey);

    // 6. Seed wallets
    await seedWallets(rpcUrl, wallets.deployer.address, wallets, seedEth);

    // 7. Start gatekeeper
    let gatekeeperUrl = rpcUrl;
    if (useGatekeeper) {
      const auditLog = join(runDir, 'rpc-audit-trail.jsonl');
      gatekeeper = createGatekeeperServer({
        upstreamUrl: rpcUrl,
        port: gatekeeperPort,
        auditLog
      });
      gatekeeperUrl = `http://localhost:${gatekeeper.port}`;
      console.log(`\nGatekeeper running on port ${gatekeeper.port}`);
    }

    // 8. Get initial balances
    const getBalance = async (address) => {
      const res = await fetch(rpcUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          jsonrpc: '2.0',
          method: 'eth_getBalance',
          params: [address, 'latest'],
          id: 1
        })
      });
      const data = await res.json();
      return (Number(BigInt(data.result || '0')) / 1e18).toFixed(4);
    };

    const attackerBalance = await getBalance(wallets.attacker.address);
    const victimBalance = await getBalance(wallets.victim.address);

    // 8b. Get initial contract balances (for fractional grading per EVMbench H.1)
    const contractInitialBalances = {};
    for (const [name, addr] of Object.entries(contracts)) {
      if (!addr) continue;
      try {
        contractInitialBalances[name] = await getBalance(addr);
      } catch {
        contractInitialBalances[name] = '0.0000';
      }
    }

    // 9. Output deploy-artifacts.json (agent-facing — no mnemonic)
    const artifacts = {
      rpc_url: gatekeeperUrl,
      anvil_rpc_url: rpcUrl,
      attacker: {
        address: wallets.attacker.address,
        private_key: attackerKey
      },
      victim: {
        address: wallets.victim.address
      },
      deployer: {
        address: wallets.deployer.address
      },
      contracts,
      initial_balances: {
        attacker_eth: attackerBalance,
        victim_eth: victimBalance,
        contracts: contractInitialBalances
      },
      anvil_port: anvilPort,
      gatekeeper_port: useGatekeeper ? gatekeeper.port : null,
      run_id: runId,
      created_at: new Date().toISOString()
    };

    const artifactsPath = join(runDir, 'deploy-artifacts.json');
    writeFileSync(artifactsPath, JSON.stringify(artifacts, null, 2));

    // Store mnemonic separately for replay grading only (not agent-facing)
    writeFileSync(join(runDir, 'grading-secrets.json'), JSON.stringify({
      mnemonic,
      anvil_port: anvilPort,
      run_id: runId
    }, null, 2));

    // Log redacted artifact summary (no private keys or mnemonic)
    const redacted = { ...artifacts, attacker: { address: artifacts.attacker.address, private_key: '[REDACTED]' } };
    console.log(`\nDeploy artifacts: ${artifactsPath}`);
    console.log(JSON.stringify(redacted, null, 2));

    // 10. Wait for timeout or signal
    console.log(`\nEnvironment ready. Will auto-shutdown in ${timeout / 1000}s.`);
    console.log('Press Ctrl+C to stop early.');

    await new Promise(resolve => setTimeout(resolve, timeout));
    console.log('\nTimeout reached. Shutting down.');
  } catch (err) {
    console.error(`\nError: ${err.message}`);
    process.exit(1);
  } finally {
    cleanup();
  }
}

if (import.meta.main !== false) {
  main().catch(err => {
    console.error('Error:', err.message);
    process.exit(1);
  });
}

export { generateMnemonic, startAnvil, deriveWallets };
