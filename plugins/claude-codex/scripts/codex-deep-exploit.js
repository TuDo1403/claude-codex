#!/usr/bin/env bun
/**
 * Codex Deep Exploit Hunt Script
 *
 * Invokes Codex CLI to perform deep exploit analysis for Stage 4B.
 * Ensures isolation from Opus output and spec prose.
 *
 * Usage:
 *   bun codex-deep-exploit.js --run-id <run_id> [--timeout 1200000]
 *
 * Environment:
 *   CLAUDE_PROJECT_DIR - Project directory
 *   CLAUDE_PLUGIN_ROOT - Plugin installation directory
 *   CODEX_API_KEY - Codex API key (optional, uses default if not set)
 */

import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';
import { join, dirname } from 'path';
import { parseArgs } from 'util';
import { execSync, spawn } from 'child_process';

const PROJECT_DIR = process.env.CLAUDE_PROJECT_DIR || process.cwd();
const PLUGIN_ROOT = process.env.CLAUDE_PLUGIN_ROOT || dirname(dirname(import.meta.path));
const TASK_DIR = join(PROJECT_DIR, '.task');
const DOCS_DIR = join(PROJECT_DIR, 'docs');

function parseArguments() {
  const { values } = parseArgs({
    options: {
      'run-id': { type: 'string' },
      'bundle-path': { type: 'string' },
      'timeout': { type: 'string' },
      help: { type: 'boolean', short: 'h' }
    },
    allowPositionals: true
  });

  if (values.help) {
    console.log(`
Usage: codex-deep-exploit.js --run-id <run_id> [options]

Invokes Codex CLI for deep exploit hunting (Stage 4B).

Options:
  --run-id       Run ID for this pipeline execution
  --bundle-path  Path to Stage 4B bundle (default: .task/<run_id>/bundle-stage4b)
  --timeout      Timeout in milliseconds (default: 1200000 = 20 minutes)
  -h, --help     Show this help message
    `);
    process.exit(0);
  }

  return values;
}

function readFile(filePath) {
  try {
    if (!existsSync(filePath)) return null;
    return readFileSync(filePath, 'utf-8');
  } catch {
    return null;
  }
}

function ensureDir(dir) {
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }
}

/**
 * Build the prompt for Codex deep exploit hunt
 */
function buildCodexPrompt(bundlePath, runId) {
  const invariantsContent = readFile(join(bundlePath, 'invariants-list.md')) || '(No invariants found)';
  const publicApiContent = readFile(join(bundlePath, 'public-api.md')) || '(No public API found)';
  const slitherContent = readFile(join(bundlePath, 'slither-summary.md')) || '(No Slither summary)';

  // Get source file list
  const srcDir = join(bundlePath, 'src');
  let sourceFiles = '';
  if (existsSync(srcDir)) {
    try {
      const files = execSync(`find "${srcDir}" -name "*.sol" -type f`, { encoding: 'utf-8' });
      sourceFiles = files.trim().split('\n').filter(f => f).join('\n');
    } catch {
      sourceFiles = '(Error listing source files)';
    }
  }

  return `You are a Codex Deep Exploit Hunter performing Stage 4B of a blind security audit.

## CRITICAL RULES

1. **BLINDNESS**: You MUST NOT see spec prose (threat-model.md, design.md narratives)
2. **ISOLATION**: You MUST NOT see Opus attack plan output (Stage 4A)
3. **REFUTATION REQUIRED**: You MUST include at least 1 refuted hypothesis with evidence
4. **FALSE POSITIVES**: You MUST invalidate at least 3 common security concerns with evidence

## YOUR BUNDLE (bundle-stage4b)

### Invariants List
${invariantsContent}

### Public API
${publicApiContent}

### Slither Summary
${slitherContent}

### Source Files Available
${sourceFiles}

## YOUR TASK

1. **Deep Exploit Analysis**
   - Hunt for non-obvious, multi-step exploit paths
   - Analyze cross-module interactions
   - Check state machine validity
   - Find exploits that span multiple contracts

2. **Refuted Hypotheses (REQUIRED)**
   - You MUST attempt at least one attack hypothesis that FAILS
   - Document WHY it fails with code references
   - This proves rigorous testing, not speculation

3. **False Positive Invalidation (REQUIRED)**
   - MUST invalidate at least 3 common concerns:
     - Reentrancy (prove CEI or guards)
     - Integer overflow (prove Solidity 0.8+ or SafeMath)
     - Access control (prove role enforcement)
   - Provide code references for each

4. **Confirmed Exploits**
   - For each confirmed exploit:
     - Severity (HIGH/MED/LOW)
     - Affected contracts
     - Attack path (step by step)
     - Invariants violated
     - Proof of concept test
     - Required fix

## OUTPUT FORMAT

You MUST produce two artifacts:

1. **docs/reviews/codex-deep-exploit-review.md** - Human-readable report
2. **.task/${runId}/codex-deep-exploit-review.json** - Machine-readable artifact

The JSON artifact MUST include:
- refuted_hypotheses: array with at least 1 item
- false_positives_invalidated: array with at least 3 items
- blindness_verified: true
- opus_isolation_verified: true

## BEGIN ANALYSIS

Read the source files in the bundle and perform deep exploit hunting.
Focus on non-obvious vulnerabilities that surface-level analysis misses.
`;
}

/**
 * Invoke Codex CLI
 */
async function invokeCodex(prompt, timeout) {
  return new Promise((resolve, reject) => {
    const codexPath = process.env.CODEX_PATH || 'codex';

    console.log('Invoking Codex CLI for deep exploit hunt...');
    console.log(`Timeout: ${timeout}ms (${Math.round(timeout / 60000)} minutes)`);

    const args = [
      '--prompt', prompt,
      '--full-auto',
      '--dangerously-auto-approve-everything'
    ];

    const child = spawn(codexPath, args, {
      cwd: PROJECT_DIR,
      env: {
        ...process.env,
        CLAUDE_PROJECT_DIR: PROJECT_DIR
      },
      stdio: ['pipe', 'pipe', 'pipe'],
      timeout
    });

    let stdout = '';
    let stderr = '';

    child.stdout.on('data', (data) => {
      stdout += data.toString();
      process.stdout.write(data);
    });

    child.stderr.on('data', (data) => {
      stderr += data.toString();
      process.stderr.write(data);
    });

    const timeoutId = setTimeout(() => {
      child.kill('SIGTERM');
      reject(new Error(`Codex timed out after ${timeout}ms`));
    }, timeout);

    child.on('close', (code) => {
      clearTimeout(timeoutId);
      if (code === 0) {
        resolve({ stdout, stderr, code });
      } else {
        reject(new Error(`Codex exited with code ${code}\n${stderr}`));
      }
    });

    child.on('error', (err) => {
      clearTimeout(timeoutId);
      reject(err);
    });
  });
}

/**
 * Create fallback output if Codex fails
 */
function createFallbackOutput(runId, error) {
  const reviewsDir = join(DOCS_DIR, 'reviews');
  ensureDir(reviewsDir);

  const timestamp = new Date().toISOString();
  const dateStr = timestamp.replace(/[-:]/g, '').split('.')[0].replace('T', '-');

  const mdContent = `# Codex Deep Exploit Review

**Reviewer:** codex-deep-exploit-hunter
**Model:** codex (FAILED)
**Bundle:** bundle-stage4b
**Date:** ${timestamp}

## Error

Codex CLI invocation failed:

\`\`\`
${error.message}
\`\`\`

## Action Required

Please run Codex deep exploit hunt manually:

\`\`\`bash
bun "${PLUGIN_ROOT}/scripts/codex-deep-exploit.js" --run-id ${runId}
\`\`\`

Or invoke Codex CLI directly with the bundle path.
`;

  writeFileSync(join(reviewsDir, 'codex-deep-exploit-review.md'), mdContent);

  const jsonContent = {
    id: `codex-deep-exploit-review-${dateStr}`,
    reviewer: 'codex-deep-exploit-hunter',
    model: 'codex',
    bundle: 'bundle-stage4b',
    blindness_verified: false,
    opus_isolation_verified: false,
    error: error.message,
    status: 'FAILED',
    confirmed_exploits: [],
    refuted_hypotheses: [],
    false_positives_invalidated: [],
    invariant_coverage: { total: 0, verified: 0, partial: 0, unverified: 0 },
    generated_at: timestamp
  };

  const runDir = join(TASK_DIR, runId);
  ensureDir(runDir);
  writeFileSync(join(runDir, 'codex-deep-exploit-review.json'), JSON.stringify(jsonContent, null, 2));

  return { md: mdContent, json: jsonContent };
}

async function main() {
  const args = parseArguments();
  const runId = args['run-id'] || `blind-audit-${Date.now()}`;
  const bundlePath = args['bundle-path'] || join(TASK_DIR, runId, 'bundle-stage4b');
  const timeout = parseInt(args.timeout || '1200000'); // 20 minutes default

  console.log(`\n=== Codex Deep Exploit Hunt ===`);
  console.log(`Run ID: ${runId}`);
  console.log(`Bundle: ${bundlePath}`);
  console.log(`Timeout: ${timeout}ms`);

  // Verify bundle exists
  if (!existsSync(bundlePath)) {
    console.error(`Bundle not found: ${bundlePath}`);
    console.log('Generating bundle first...');

    try {
      execSync(`bun "${join(PLUGIN_ROOT, 'scripts', 'generate-bundle-stage4b.js')}" --run-id ${runId}`, {
        cwd: PROJECT_DIR,
        stdio: 'inherit'
      });
    } catch (err) {
      console.error('Failed to generate bundle:', err.message);
      process.exit(1);
    }
  }

  // Verify bundle manifest
  const manifestPath = join(bundlePath, 'MANIFEST.json');
  if (existsSync(manifestPath)) {
    try {
      const manifest = JSON.parse(readFileSync(manifestPath, 'utf-8'));
      if (!manifest.isolation_validated) {
        console.error('Bundle isolation not validated - Opus output may be present');
        process.exit(1);
      }
      console.log('Bundle isolation verified: Opus output excluded');
    } catch (err) {
      console.warn('Could not verify bundle manifest:', err.message);
    }
  }

  // Build prompt
  const prompt = buildCodexPrompt(bundlePath, runId);

  try {
    const result = await invokeCodex(prompt, timeout);
    console.log('\nCodex completed successfully');

    // Verify output was created
    const jsonPath = join(TASK_DIR, runId, 'codex-deep-exploit-review.json');
    const mdPath = join(DOCS_DIR, 'reviews', 'codex-deep-exploit-review.md');

    if (existsSync(jsonPath)) {
      console.log(`JSON artifact: ${jsonPath}`);
    } else {
      console.warn('Warning: JSON artifact not created by Codex');
    }

    if (existsSync(mdPath)) {
      console.log(`MD report: ${mdPath}`);
    } else {
      console.warn('Warning: MD report not created by Codex');
    }

    console.log(JSON.stringify({
      success: true,
      run_id: runId,
      json_path: jsonPath,
      md_path: mdPath
    }));
  } catch (error) {
    console.error('\nCodex invocation failed:', error.message);

    // Create fallback output
    const fallback = createFallbackOutput(runId, error);
    console.log('Created fallback output for manual retry');

    console.log(JSON.stringify({
      success: false,
      run_id: runId,
      error: error.message,
      fallback_created: true
    }));

    process.exit(1);
  }
}

main().catch(err => {
  console.error('Error:', err.message);
  process.exit(1);
});
