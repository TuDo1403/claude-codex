#!/usr/bin/env bun
/**
 * Codex Deep Exploit Hunt Script
 *
 * Invokes Codex CLI to perform deep exploit analysis for Stage 4B.
 * Ensures isolation from Opus output and spec prose.
 *
 * Usage:
 *   bun codex-deep-exploit.js --run-id <run_id> [--timeout 1200000]
 *
 * Environment:
 *   CLAUDE_PROJECT_DIR - Project directory
 *   CLAUDE_PLUGIN_ROOT - Plugin installation directory
 *   CODEX_API_KEY - Codex API key (optional, uses default if not set)
 */

import { readFileSync, writeFileSync, existsSync, mkdirSync, readdirSync } from 'fs';
import { join, dirname } from 'path';
import { parseArgs } from 'util';
import { execSync, spawn } from 'child_process';

const PROJECT_DIR = process.env.CLAUDE_PROJECT_DIR || process.cwd();
const PLUGIN_ROOT = process.env.CLAUDE_PLUGIN_ROOT || dirname(dirname(import.meta.path));
const TASK_DIR = join(PROJECT_DIR, '.task');
const DOCS_DIR = join(PROJECT_DIR, 'docs');

function loadCodexStageConfig(stageKey) {
  try {
    const configPath = join(PROJECT_DIR, '.claude-codex.json');
    if (!existsSync(configPath)) return null;
    const config = JSON.parse(readFileSync(configPath, 'utf8'));
    return config?.codex_stages?.[stageKey] ?? null;
  } catch {
    return null;
  }
}

function writeExecutionLog(stage, data) {
  try {
    const logsDir = join(PROJECT_DIR, 'reports', 'execution-logs');
    mkdirSync(logsDir, { recursive: true });
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const logFile = join(logsDir, `${stage}-${timestamp}.log`);
    const content = Object.entries(data)
      .map(([k, v]) => `${k}: ${v}`)
      .join('\n') + '\n';
    writeFileSync(logFile, content);
  } catch {
    // Non-critical, don't fail
  }
}

/**
 * Parse token usage from Codex CLI output (G9)
 */
function parseTokenUsage(stdout, stderr) {
  const combined = (stdout || '') + '\n' + (stderr || '');
  const usage = { input_tokens: 0, output_tokens: 0, total_tokens: 0 };
  let found = false;
  const nestedPattern = /"usage"\s*:\s*\{([^}]+)\}/g;
  let match;
  while ((match = nestedPattern.exec(combined)) !== null) {
    try {
      const usageObj = JSON.parse(`{${match[1]}}`);
      usage.input_tokens += usageObj.input_tokens || usageObj.prompt_tokens || 0;
      usage.output_tokens += usageObj.output_tokens || usageObj.completion_tokens || 0;
      found = true;
    } catch { /* skip */ }
  }
  const totalMatch = combined.match(/total[_ ]tokens?\s*[:=]\s*(\d+)/i);
  if (totalMatch && !found) {
    usage.total_tokens = parseInt(totalMatch[1]);
    found = true;
  }
  if (found) {
    usage.total_tokens = usage.total_tokens || (usage.input_tokens + usage.output_tokens);
    return usage;
  }
  return null;
}

function parseArguments() {
  const { values } = parseArgs({
    options: {
      'run-id': { type: 'string' },
      'bundle-path': { type: 'string' },
      'timeout': { type: 'string' },
      help: { type: 'boolean', short: 'h' }
    },
    allowPositionals: true
  });

  if (values.help) {
    console.log(`
Usage: codex-deep-exploit.js --run-id <run_id> [options]

Invokes Codex CLI for deep exploit hunting (Stage 4B).

Options:
  --run-id       Run ID for this pipeline execution
  --bundle-path  Path to Stage 4B bundle (default: .task/<run_id>/bundle-stage4b)
  --timeout      Timeout in milliseconds (default: 1200000 = 20 minutes)
  -h, --help     Show this help message
    `);
    process.exit(0);
  }

  return values;
}

function readFile(filePath) {
  try {
    if (!existsSync(filePath)) return null;
    return readFileSync(filePath, 'utf-8');
  } catch {
    return null;
  }
}

function ensureDir(dir) {
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }
}

/**
 * Write INSTRUCTIONS.md to bundlePath for exec mode (G6).
 */
function writeInstructions(bundlePath, runId) {
  // List source files using fs instead of exec
  const srcDir = join(bundlePath, 'src');
  let sourceFilesList = '';
  if (existsSync(srcDir)) {
    try {
      const listSol = (dir) => {
        const results = [];
        for (const entry of readdirSync(dir, { withFileTypes: true })) {
          const full = join(dir, entry.name);
          if (entry.isDirectory()) results.push(...listSol(full));
          else if (entry.name.endsWith('.sol')) results.push(full.replace(bundlePath + '/', ''));
        }
        return results;
      };
      sourceFilesList = listSol(srcDir).map(f => `- \`${f}\``).join('\n');
    } catch {
      sourceFilesList = '(Error listing source files)';
    }
  }

  const instructions = `# Codex Deep Exploit Hunt — INSTRUCTIONS

You are a Codex Deep Exploit Hunter performing Stage 4B of a blind security audit.

## CRITICAL RULES

1. **BLINDNESS**: You MUST NOT see spec prose (threat-model.md, design.md narratives)
2. **ISOLATION**: You MUST NOT see Opus attack plan output (Stage 4A)
3. **REFUTATION REQUIRED**: You MUST include at least 1 refuted hypothesis with evidence
4. **FALSE POSITIVES**: You MUST invalidate at least 3 common security concerns with evidence

## BUNDLE FILES (read from current directory)

- \`invariants-list.md\` — Invariants for the codebase
- \`public-api.md\` — Public API surface
- \`slither-summary.md\` — Static analysis results

## SOURCE FILES

${sourceFilesList || '(No source files found — check src/ directory)'}

## YOUR TASK

Read the files listed above from the current directory, then:

1. **Deep Exploit Analysis**
   - Hunt for non-obvious, multi-step exploit paths
   - Analyze cross-module interactions
   - Check state machine validity
   - Find exploits that span multiple contracts

2. **Refuted Hypotheses (REQUIRED)**
   - You MUST attempt at least one attack hypothesis that FAILS
   - Document WHY it fails with code references
   - This proves rigorous testing, not speculation

3. **False Positive Invalidation (REQUIRED)**
   - MUST invalidate at least 3 common concerns:
     - Reentrancy (prove CEI or guards)
     - Integer overflow (prove Solidity 0.8+ or SafeMath)
     - Access control (prove role enforcement)
   - Provide code references for each

4. **Confirmed Exploits**
   - For each confirmed exploit:
     - Severity (HIGH/MED/LOW)
     - Affected contracts
     - Attack path (step by step)
     - Invariants violated
     - Proof of concept test
     - Required fix

## OUTPUT FORMAT

You MUST produce two artifacts in the current directory:

1. **codex-deep-exploit-review.md** — Human-readable report
2. **codex-deep-exploit-review.json** — Machine-readable artifact

The JSON artifact MUST include:
- refuted_hypotheses: array with at least 1 item
- false_positives_invalidated: array with at least 3 items
- blindness_verified: true
- opus_isolation_verified: true

## BEGIN ANALYSIS

Read the source files in the bundle and perform deep exploit hunting.
Focus on non-obvious vulnerabilities that surface-level analysis misses.
`;

  writeFileSync(join(bundlePath, 'INSTRUCTIONS.md'), instructions);
}

/**
 * Invoke Codex CLI in exec mode (G6).
 * cwd is set to bundlePath so Codex reads bundle files directly.
 */
async function invokeCodex(bundlePath, runId, timeout) {
  return new Promise((resolve, reject) => {
    const codexPath = process.env.CODEX_PATH || 'codex';

    console.log('Invoking Codex CLI (exec mode) for deep exploit hunt...');
    console.log(`Timeout: ${timeout}ms (${Math.round(timeout / 60000)} minutes)`);

    const stageConfig = loadCodexStageConfig('exploit');

    const args = [
      'exec',
      '--full-auto',
      '--skip-git-repo-check'
    ];

    if (stageConfig?.model) {
      args.push('-m', stageConfig.model);
    }
    if (stageConfig?.reasoning) {
      args.push('-c', `model_reasoning_effort="${stageConfig.reasoning}"`);
    }

    args.push('Read INSTRUCTIONS.md and perform deep exploit hunting. Write findings to codex-deep-exploit-review.json and codex-deep-exploit-review.md in the current directory.');

    const child = spawn(codexPath, args, {
      cwd: bundlePath,
      env: {
        ...process.env,
        CLAUDE_PROJECT_DIR: PROJECT_DIR
      },
      stdio: ['pipe', 'pipe', 'pipe'],
      timeout
    });

    let stdout = '';
    let stderr = '';

    child.stdout.on('data', (data) => {
      stdout += data.toString();
      process.stdout.write(data);
    });

    child.stderr.on('data', (data) => {
      stderr += data.toString();
      process.stderr.write(data);
    });

    const timeoutId = setTimeout(() => {
      child.kill('SIGTERM');
      reject(new Error(`Codex timed out after ${timeout}ms`));
    }, timeout);

    child.on('close', (code) => {
      clearTimeout(timeoutId);
      if (code === 0) {
        resolve({ stdout, stderr, code });
      } else {
        reject(new Error(`Codex exited with code ${code}\n${stderr}`));
      }
    });

    child.on('error', (err) => {
      clearTimeout(timeoutId);
      reject(err);
    });
  });
}

/**
 * Create fallback output if Codex fails
 */
function createFallbackOutput(runId, error) {
  const reviewsDir = join(DOCS_DIR, 'reviews');
  ensureDir(reviewsDir);

  const timestamp = new Date().toISOString();
  const dateStr = timestamp.replace(/[-:]/g, '').split('.')[0].replace('T', '-');

  const mdContent = `# Codex Deep Exploit Review

**Reviewer:** codex-deep-exploit-hunter
**Model:** codex (FAILED)
**Bundle:** bundle-stage4b
**Date:** ${timestamp}

## Error

Codex CLI invocation failed:

\`\`\`
${error.message}
\`\`\`

## Action Required

Please run Codex deep exploit hunt manually:

\`\`\`bash
bun "${PLUGIN_ROOT}/scripts/codex-deep-exploit.js" --run-id ${runId}
\`\`\`

Or invoke Codex CLI directly with the bundle path.
`;

  writeFileSync(join(reviewsDir, 'codex-deep-exploit-review.md'), mdContent);

  const jsonContent = {
    id: `codex-deep-exploit-review-${dateStr}`,
    reviewer: 'codex-deep-exploit-hunter',
    model: 'codex',
    bundle: 'bundle-stage4b',
    blindness_verified: false,
    opus_isolation_verified: false,
    error: error.message,
    status: 'FAILED',
    confirmed_exploits: [],
    refuted_hypotheses: [],
    false_positives_invalidated: [],
    invariant_coverage: { total: 0, verified: 0, partial: 0, unverified: 0 },
    generated_at: timestamp
  };

  const runDir = join(TASK_DIR, runId);
  ensureDir(runDir);
  writeFileSync(join(runDir, 'codex-deep-exploit-review.json'), JSON.stringify(jsonContent, null, 2));

  return { md: mdContent, json: jsonContent };
}

async function main() {
  const args = parseArguments();
  const runId = args['run-id'] || `blind-audit-${Date.now()}`;
  const bundlePath = args['bundle-path'] || join(TASK_DIR, runId, 'bundle-stage4b');
  const timeout = parseInt(args.timeout || '1200000'); // 20 minutes default

  console.log(`\n=== Codex Deep Exploit Hunt ===`);
  console.log(`Run ID: ${runId}`);
  console.log(`Bundle: ${bundlePath}`);
  console.log(`Timeout: ${timeout}ms`);

  // Verify bundle exists
  if (!existsSync(bundlePath)) {
    console.error(`Bundle not found: ${bundlePath}`);
    console.log('Generating bundle first...');

    try {
      execSync(`bun "${join(PLUGIN_ROOT, 'scripts', 'generate-bundle-stage4b.js')}" --run-id ${runId}`, {
        cwd: PROJECT_DIR,
        stdio: 'inherit'
      });
    } catch (err) {
      console.error('Failed to generate bundle:', err.message);
      process.exit(1);
    }
  }

  // Verify bundle manifest
  const manifestPath = join(bundlePath, 'MANIFEST.json');
  if (existsSync(manifestPath)) {
    try {
      const manifest = JSON.parse(readFileSync(manifestPath, 'utf-8'));
      if (!manifest.isolation_validated) {
        console.error('Bundle isolation not validated - Opus output may be present');
        process.exit(1);
      }
      console.log('Bundle isolation verified: Opus output excluded');
    } catch (err) {
      console.warn('Could not verify bundle manifest:', err.message);
    }
  }

  // Write INSTRUCTIONS.md to bundle (G6: exec mode)
  writeInstructions(bundlePath, runId);

  const startTime = Date.now();

  try {
    const result = await invokeCodex(bundlePath, runId, timeout);
    console.log('\nCodex completed successfully');

    // Codex writes output to bundlePath in exec mode; copy to canonical locations
    const bundleJsonPath = join(bundlePath, 'codex-deep-exploit-review.json');
    const bundleMdPath = join(bundlePath, 'codex-deep-exploit-review.md');
    const jsonPath = join(TASK_DIR, runId, 'codex-deep-exploit-review.json');
    const mdPath = join(DOCS_DIR, 'reviews', 'codex-deep-exploit-review.md');

    if (existsSync(bundleJsonPath)) {
      ensureDir(join(TASK_DIR, runId));
      writeFileSync(jsonPath, readFileSync(bundleJsonPath, 'utf-8'));
    }
    if (existsSync(bundleMdPath)) {
      ensureDir(join(DOCS_DIR, 'reviews'));
      writeFileSync(mdPath, readFileSync(bundleMdPath, 'utf-8'));
    }

    if (existsSync(jsonPath)) {
      console.log(`JSON artifact: ${jsonPath}`);
    } else {
      console.warn('Warning: JSON artifact not created by Codex');
    }

    if (existsSync(mdPath)) {
      console.log(`MD report: ${mdPath}`);
    } else {
      console.warn('Warning: MD report not created by Codex');
    }

    const durationMs = Date.now() - startTime;
    const exploitStageConfig = loadCodexStageConfig('exploit');
    const tokenUsage = parseTokenUsage(result.stdout, result.stderr);
    const logData = {
      start_time: new Date(startTime).toISOString(),
      model: exploitStageConfig?.model || 'default',
      reasoning: exploitStageConfig?.reasoning || 'default',
      timeout_ms: timeout,
      exit_code: 0,
      duration_ms: durationMs,
      run_id: runId
    };
    if (tokenUsage) {
      logData.input_tokens = tokenUsage.input_tokens;
      logData.output_tokens = tokenUsage.output_tokens;
      logData.total_tokens = tokenUsage.total_tokens;
    }
    writeExecutionLog('deep-exploit', logData);

    console.log(JSON.stringify({
      success: true,
      run_id: runId,
      json_path: jsonPath,
      md_path: mdPath
    }));
  } catch (error) {
    console.error('\nCodex invocation failed:', error.message);

    // Create fallback output
    const fallback = createFallbackOutput(runId, error);
    console.log('Created fallback output for manual retry');

    const durationMs = Date.now() - startTime;
    const exploitStageConfig = loadCodexStageConfig('exploit');
    writeExecutionLog('deep-exploit', {
      start_time: new Date(startTime).toISOString(),
      model: exploitStageConfig?.model || 'default',
      reasoning: exploitStageConfig?.reasoning || 'default',
      timeout_ms: timeout,
      exit_code: 1,
      duration_ms: durationMs,
      run_id: runId,
      error: error.message
    });

    console.log(JSON.stringify({
      success: false,
      run_id: runId,
      error: error.message,
      fallback_created: true
    }));

    process.exit(1);
  }
}

main().catch(err => {
  console.error('Error:', err.message);
  process.exit(1);
});
